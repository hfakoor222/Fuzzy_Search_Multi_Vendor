


#######################################################################################################
Welcome to configuration template parser program. This program parses multivendor devices.
Currently ASA, Cisco IOS, IOS-XE,  and Juniper router devices are supported.
We input a template and compare fuzzy searches across devices and return matches if exists.

the port in your environment should be set to 22 for SSH
make sure to allow python through your firewall

program splits device templates using  $$$  and splits configurations fed into each template/device using   $$

to add a configuration template begin with a configuration template name:
supported names:
asa_template
ios_template
junos_template


after which we add a list of lists (enclosed in exterior brackets) for ip addresses and connection information

ip_address = [[ip_address1 , username1 , password1, SSH_password1 ], [ip_address2, username2, password2, ""]] 

notice the double brackets at the beginning and end.  The SSH password can be an empty string if desired, depending on device platform.
junos does not require a secret for running this script, we leave blank by using "" 

example:
ip_address = [[10.0.0.1, cisco, cisco123, secret], [10.0.0.2, cisco, cisco123, secret],
		[10.0.0.3, user_x, password_x, secret]
		[10.0.0.4, user_x, password_x, secret]]


after this we can define our templates. 

Templates are parsed using $, and (())
$ signifies any characters, spaces, and a optional newline,
whereas (()) signifies any characters without spaces,  
in regular-expression terms:
$     =  .*?
(())  =  \S+
(()) signifies at least 1 character must exist.
 
so for example:

router ospf ((5))
router-id $
network $ area 0

means that this configuration below

router ospf 6
router-id 5.5.5.5
domain-tag 55
network 192.168.0.0 0.0.0.255 area 0

will be found due optional match (())
and  $ =  any character (in this case 5.5.5.5)

we can also do this:

router ospf $
$
network 192.168.0.0



for example in a cisco "show run" we see:
!
interface Serial1/3
 no ip address
!
router eigrp 65001
 network 10.0.0.0
 network 192.168.14.0
!
router ospf 1
 router-id 6.6.6.6
 domain-tag 55
 passive-interface Ethernet0/3
 network 10.0.1.0 0.0.0.127 area 1
 network 10.0.1.128 0.0.0.127 area 1
 network 155.55.55.0 0.0.0.127 area 0
 default-information originate

!


so we will be matching on the below for example:

router ospf 1
 router-id 6.6.6.6
 domain-tag 55
 passive-interface Ethernet0/3
 network 10.0.1.0 0.0.0.127 area 1
 network 10.0.1.128 0.0.0.127 area 1
 network 155.55.55.0 0.0.0.127 area 0
 default-information originate


We can include both fuzzy and exact templates under the same configuration template for deeper searches.

Lets do the search: 

ios_template
ip_address = [[10.0.1.1, cisco, cisco123, cisco123], [10.0.1.2, cisco, cisco123, cisco123], 
[10.0.1.130, cisco, cisco123, cisco123], [10.0.3.4, cisco, cisco123, cisco123]]
$$
router ospf (())
router-id (())
network 10.0.(()).(()) area (())
$$
router ospf $
router-id (())
network $
$
network 10.0.(()).(()) area (())
network $


The first configuration will not match, this is because there is the "domain-tag" word between "router-id" and "network" statements

However the second template matches:

router ospf $
router-id (())
network $
$
network 10.0.(()).(()) area (())
network $

Notice we used the $ sign. This could signify 0 or 1 line of any characters. So it matched. This gives us a lot of control to do fuzzy searches, to see if something is off in our configuration.



Here's one more example -   remember the  double  $$ is used to split the templates, a single $ is used as a control character that signals any amount of characters including spaces, newline, tabs, numbers, etc, and it is non-greedy, meaning it runs for 1 line:


ios_template
ip_address = [[10.0.1.1, cisco, cisco123, cisco123], [10.0.1.2, cisco, cisco123, cisco123], 
[10.0.1.130, cisco, cisco123, cisco123]]
$$
router bgp 65001
$
$
$
neighbor 10.1.$ remote-as $
neighbor $ remote-as $
$
$$
router bgp $
$


so this is out first template:

router bgp 65001
$
$
$
neighbor 10.1.$ remote-as $
neighbor $ remote-as $
$

this matches any bgp configuration in AS  65001, with various configurations mixed in between the 'router bgp' and 'neighbor remote-as' statements.
This configuration show that at least 2 neighbors have to be present and one of them must begin with 10.1.   address.



